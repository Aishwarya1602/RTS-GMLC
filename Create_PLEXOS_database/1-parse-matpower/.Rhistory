# other.inputs <- "create_other_inputs.R" # old
other.inputs <- "create_other_inputs_rts2016.R"# new
output.dir <- "outputs"
#------------------------------------------------------------------------------|
#------------------------------------------------------------------------------|
# nesta opf format parser - based on NESTA v0.6.0
# -----------------------------------------------
#
#   format requirements:
#       - one function that creates and returns a matlab struct of
#         tables and strings
#       - comments that procede tables are two lines.
#               first: %% data_description
#               second: % col1  col2    col3, etc
#
#       - colnames have no spaces
#       - function definition has an output, an equal sign, and no arguments
#       - fields are either one-liner strings or tables that begin with
#           'strucname.name = [' and end with '];'
#
#------------------------------------------------------------------------------|
#------------------------------------------------------------------------------|
#------------------------------------------------------------------------------|
# helper functions ----
#------------------------------------------------------------------------------|
func.obj.init <- function(dt) {
# args: data.table with a column called orig.text
# use: finds where function is defined
# result: global environent variables: case.name, struct.name (to be used
#   for building list of elemnts), and stuct.list (empty list to be
#   populated as the rest of the file is parsed)
# find function definition
funct.decl <- which(grepl("^function.*=", dt$orig.text))
if (length(funct.decl) == 0) {
stop(paste("It looks like there is either no function declaration",
"in this file or that no function declarations define",
sprintf("an output. Please check your file, %s", file.p)))
} else if (length(funct.decl) > 1) {
stop(paste("It looks like there is more than one function definition",
"in this file. This script cannot handle that at the moment.",
sprintf("Please check your file, %s", file.p)))
}
# initialize global variables to be accessed by other functions
case.name <- dt[funct.decl, tstrsplit(orig.text, "=")[[2]]]
case.name <<- gsub(" ", "", case.name)
struct.name <- dt[funct.decl, tstrsplit(orig.text, "=")[[1]]]
struct.name <<- gsub("function| ", "", struct.name)
struct.list <<- list()
}
func.find.objs <- function(dt, strct.strng) {
# find indices for all fields added to the structure
# assumes has one one-liners and tables.
#   one.lines: index will be index of the line where everything is defined
#   tables: begin index is line with table name; row names are one up;
#       data starts one down
#           end index is line after last line of data
#
file.dt[grepl(paste0("^[^%]*",strct.strng, "\\..*="), orig.text),
obj.new := TRUE]
file.dt[grepl("=.*\\[", orig.text) & obj.new == TRUE, tag := "table.beg"]
file.dt[grepl("\\]", orig.text) & is.na(obj.new), tag := "table.end"]
file.dt[obj.new & is.na(tag), tag := "one.line"]
# grab info
file.dt[,index := .I]
field.loc <- file.dt[!is.na(tag),.(tag, index)]
# clean up
file.dt[,c("obj.new", "index", "tag") := NULL]
return(field.loc)
}
func.build.list <- function(dt, obj.locs) {
# from already created tables, pull out elements and add them to a list
# of all objects in the .m file
if (nrow(obj.locs[!(tag %in% c("one.line", "table.beg", "table.end"))])) {
stop(paste("Input obj.locs table has at least one tag that isn't",
"one.line, table.beg, table.end. Don't know how to handle",
"that. Please check the table"))
}
for (i in seq(nrow(obj.locs))) {
# get object name
i.str <- dt[obj.locs[i, index], orig.text]
i.name <- tstrsplit(i.str, "=")[[1]]
i.name <- gsub(paste0(" |", struct.name, "\\."), "", i.name)
# get value, which changes based on type
if (obj.locs[i,tag] == "one.line") {
i.value <- tstrsplit(i.str, "=")[[2]]
i.value <- gsub(" |;|\\'", "", i.value)
struct.list[[i.name]] <- i.value
} else if (obj.locs[i, tag] == "table.beg") {
# get and clean table (collapse spaces into tabs, break into table)
i.table <- dt[obj.locs[i, index+1]:obj.locs[i+1, index-1],
# tstrsplit(gsub(";","",gsub("\\s+", "\t", orig.text)), "\t| ")]
tstrsplit(gsub(";","", orig.text), "\t|\\s+")]
# deal with nans if needed
for (j in names(i.table)) {
set(i.table, which(i.table[[j]] == "nan"), j, NA)
}
# remove first col if is blank
if (all(i.table[[1]] == "" | is.na(i.table[[1]]))) {
i.table[, (1) := NULL] # this is sloppy
}
# get prev line, assuming is colnames
i.colnames <- dt[obj.locs[i, index-1]]
if (!grepl("%", i.colnames)) {
message(paste0("couldn't find column names in line above ",
"table beginning. please check format of table ",
struct.name, ".", i.name, ". In the mean time, ",
"labelling columns with generic names."))
i.colnames <- paste("V", 1:ncol(i.table),
sep = "", collapse = "\t")
}
# set new column nanes
i.colnames <- unlist(tstrsplit(i.colnames, "\t|\\s+"))
i.colnames <- i.colnames[!grepl("%", i.colnames)]
# treat gencost as a special case
if (i.name == "gencost") {
# set names for first four (non-variable) columns
setnames(i.table,
names(i.table[,.SD, .SDcols = 1:4]),
c("model", "startup", "shutdown", "n"))
# determine if is piecewise linear or polynomial
if (length(unique(i.table$model)) > 1) {
stop("I don't know how to handle multiple gen cost types yet")
}
if (unique(i.table$model) == "1") {
# name using model "1" scheme (n = number of piecewise
# linear segments and subsequent cols are named
# p0, c0,...,p(n-1),c(n-1)
tab.names <- names(i.table)
tab.names <- tab.names[grepl("^V", tab.names)]
if (length(tab.names) != 2 * as.numeric(i.table[,max(n)])) {
stop(paste0("max2 * (n) is not equal to the number of extra ",
"columns in gen.cost. Please verify data is",
"in the right format"))
}
new.names.p <- paste0("p", 0:(length(tab.names)/2 - 1))
new.names.f <- paste0("f", 0:(length(tab.names)/2 - 1))
new.names <- c(rbind(new.names.p, new.names.f))
setnames(i.table,
tab.names,
new.names)
}
if (unique(i.table$model) == "2") {
# name using model "2" scheme (n = number of coefficients
# in polynomial and subsequent cols are named c(n-1) - c0)
tab.names <- names(i.table)
tab.names <- tab.names[grepl("^V", tab.names)]
if (length(tab.names) != i.table[,max(n)]) {
stop(paste0("max(n) is not equal to the number of extra ",
"columns in gen.cost. Please verify data is",
"in the right format"))
}
new.names <- paste0("c", (length(tab.names) - 1):0)
setnames(i.table,
tab.names,
new.names)
}
} else { # any table but gencost
# adjust name setting if there is an error
tryCatch(setnames(i.table, colnames(i.table), i.colnames),
error =  function(e) {
if (length(i.colnames) < length(colnames(i.table))) {
message(paste0("not enough new colnames for table ",
struct.name, ".", i.name,
". leaving some cols unnameed. ",
"please check table."))
setnames(i.table,
colnames(i.table)[seq_along(i.colnames)],
i.colnames)
} else {
message(paste0("too many new colnames for table ",
struct.name, ".", i.name,
". exluding extras. ",
"please check table."))
setnames(i.table,
colnames(i.table),
i.colnames[seq_along(colnames(i.table))])
}}
)
}
# now that table is created and renames, add to list
struct.list[[i.name]] <- i.table
} else if (obj.locs[i, tag] == "table.beg") {
next
}
}
return(struct.list)
}
#------------------------------------------------------------------------------|
# read in and parse file ----
#------------------------------------------------------------------------------|
# read in file
file.dt <- data.table(orig.text = readLines(file.p))
# get rid of blanks at beginnings of lines and blank lines
file.dt[,orig.text := gsub("^\\s+|^\t", "", orig.text)]
file.dt <- file.dt[orig.text != ""]
# pull out name, object name
#   creates vars case.name, struct.name, struct.list
func.obj.init(file.dt)
# prep for real parsing
if (!(exists("case.name")|exists("struct.name")|exists("struct.list"))) {
stop(paste("At least one of case.name, struct.name, and struct.list",
"doesn't exist. Please initialize these by running",
"func.obj.init"))
}
# id where new objects are
field.loc <- func.find.objs(file.dt, struct.name)
# for all objects, grab and put in list
struct.list <- func.build.list(file.dt, field.loc)
#------------------------------------------------------------------------------|
# reformat for use in scripts ----
#------------------------------------------------------------------------------|
# regions
region.refnode.data <- struct.list$areas[,.(Region = area,
`Region.Reference Node` = refbus)]
# nodes
node.data <- struct.list$bus[,.(Node = bus_i, Voltage = baseKV, Region = area,
Zone = zone)]
# node lpf TODO
node.data <- struct.list$bus[,.(Node = bus_i, Voltage = baseKV, Region = area,
Zone = zone)]
# generators
generator.data <- struct.list$gen[,.(Node = bus, Units = status,
`Max Capacity` = Pmax)]
generator.data[,id := 1:.N, by = Node]
generator.data[,Generator := paste0(Node, "_", id)]
generator.data[,id := NULL]
# change synchronous condenser max capacity from NA to 0
generator.data[is.na(`Max Capacity`), `Max Capacity` := '0']
gencost <- struct.list$gencost
# lines
line.data <- struct.list$branch[,.(`Node From` = fbus, `Node To` = tbus,
Resistance = r, Reactance = x,
`Max Flow` = rateA, rateA, rateB, rateC,
Units = status)]
line.data[,id := 1:.N, by = .(`Node To`, `Node From`)]
line.data[,Line := paste0(`Node From`, "_", `Node To`, "_", id)]
line.data[,id := NULL]
line.data[,`Min Flow` := -1 * as.numeric(`Max Flow`)]
setcolorder(line.data,unique(c("Line",names(line.data))))
all.tabs <- c()
View(generator.data)
View(generator.data)
if (!exists("all.tabs")) all.tabs <- c()
gen.params = fread('../../RTS_Data/gen_params.csv')
gen.id = fread('../../RTS_Data/gen_id.csv')
View(gen.params)
View(gen.id)
node.data[, Zone := as.numeric(Region)]
node.data[, Region := substr(Region, 1, 1)] # just tens digit
# add to all.tabs
all.tabs <- c(all.tabs, "node.data")
#------------------------------------------------------------------------------|
# add load datafile pointers to nodes that have load on them ----
#------------------------------------------------------------------------------|
# hardcode reigonal filepointers
region.load.da <- data.table(Region = c(1:3),
Load = "timeseries_data_files\\load\\DA_hourly.csv")
region.load.rt <- data.table(Region = c(1:3),
Load = "timeseries_data_files\\load\\RT_5min.csv")
# add to all.tabs
all.tabs <- c(all.tabs, "region.load.da", "region.load.rt")
#------------------------------------------------------------------------------|
# add load participation factor for load nodes ----
#------------------------------------------------------------------------------|
# can leave node load in MW; psse2plexos will normalize
node.lpf <- struct.list$bus[,.(Node = bus_i, Load = Pd, Status = 1)]
# add to all.tabs
all.tabs <- c(all.tabs, "node.lpf")
gen.fuel <- gen.id[,Generator := paste0(Bus, "_", ID)]
View(gen.fuel)
gen.fuel <- gen.fuel[,.(Generator, Type = Unit)]
View(gen.fuel)
fuels <- gen.params[,.(Type = Unit, Fuel)]
gen.fuel <- merge(gen.fuel, fuels, all.x = TRUE, by='Type')
View(gen.fuel)
gen.fuel <- gen.id[,Generator := paste0(Bus, "_", ID)]
gen.fuel <- gen.fuel[,.(Generator, Type = Unit)]
# fuel type to unit type
fuels <- gen.params[,.(Type = Unit, Fuel)]
# fuel type to generator
gen.fuel <- merge(gen.fuel, fuels, all.x = TRUE, by='Type')
# leave only Generator and Fuel columns
gen.fuel[,Type := NULL]
# add fuel to synchronous condensers
gen.fuel[is.na(Fuel), Fuel := 'SynchCond']
# get fuel price (2010$/MMBtu)
fuel.price <- fread("../../RTS_Data/fuel_prices.csv")
fuel.price[, Price := round(Price, 3)]
# add to get written out
all.tabs <- c(all.tabs, "gen.fuel", "fuel.price")
#------------------------------------------------------------------------------|
# generator outages by type ----
#------------------------------------------------------------------------------|
# read gen types
gen.type = gen.id[,Generator := paste0(Bus, "_", ID)]
gen.type = gen.type[,.(Generator, Unit)]
# read generator outage info
gen.outages = gen.params[, .(Unit, `Forced Outage Rate` = Outage, `Mean Time to Repair` = MTTR)]
# combine gens to outage
gen.outages = merge(gen.type, gen.outages, all.x=TRUE, by='Unit')
gen.outages = gen.outages[, .(Generator, `Forced Outage Rate`, `Mean Time to Repair`)]
# set outage for synchronous condensers to 0
gen.outages[is.na(`Forced Outage Rate`), ":=" (`Forced Outage Rate` = 0, `Mean Time to Repair` = 0)]
# add to get written out
all.tabs <- c(all.tabs, "gen.outages")
#------------------------------------------------------------------------------|
# cost data ----
#------------------------------------------------------------------------------|
#
gen.cost.data <- cbind(generator.data[,.(Generator)],
struct.list$gencost)
# remove unneeded cols
model <- gen.cost.data[1,model]
gen.cost.data[,c("model", "startup", "shutdown", "n") := NULL]
if (model == 1) {
# assumes heat rates are in $/hr and calculated using a dummy fuel price
# of $1/MMBtu
# converts from $/hr to MMBtu/MWh by diving by load point
# ($/hr * 1 MMBtu/$1 * 1 hr/[loadpoint MW * hr = MWh])
# reset names to be load point and heat rate for plexos
names.to.convert <- names(gen.cost.data)
names.to.convert <- names.to.convert[names.to.convert != "Generator"]
names.converted <- gsub("p", "Load Point", names.to.convert)
names.converted <- gsub("f", "Heat Rate", names.converted)
setnames(gen.cost.data, names.to.convert, names.converted)
# names are almost plexos names, but have band id numbers at end
# now, melt down, get band id, convert to real MMBtu/MWh
# there is probably a fancier/more efficient way to do this
gen.cost.data <- melt(gen.cost.data, id.vars = "Generator",
variable.factor = FALSE, value.factor = FALSE)
gen.cost.data[, Band := as.numeric(substr(variable,
nchar(variable),
nchar(variable))) + 1]
gen.cost.data[,variable := substr(variable, 1, nchar(variable) - 1)]
# recast to get all Load Point and Heat Rate back as column names
gen.cost.data[,value := as.numeric(value)]
gen.cost.data <- data.table(dcast(gen.cost.data, Generator+Band~variable))
gen.cost.data = merge(gen.cost.data,
merge(gen.fuel,
fuel.price,by='Fuel')[,.(Generator,Price)],
by='Generator')
# heat rate is in $/hr, assuming fuel is $1/MMBtu. Convert to MMBtu/MWh
gen.cost.data[, `Heat Rate` := `Heat Rate`/(`Load Point`*`Price`)][,Price:=NULL]
# TODO HMMM SOMETHING IS WRONG WITH THESE HEAT RATE NUMBERS
} else if (model == 2) {
# polynomial function coefficients
# reset names to be plexos properties
setnames(gen.cost.data, "c0", "Heat Rate Base")
# reset numbering of c to index from 1
names.to.convert <- names(gen.cost.data)
names.converted <- names.to.convert[grepl("^c", names.to.convert)]
names.converted <- gsub("c", "", names.converted)
names.converted <- as.character(as.numeric(names.converted) + 1)
names.converted <- paste("Heat Rate Incr", names.converted)
setnames(gen.cost.data,
names.to.convert,
names.converted)
} else {
stop("heat rate model is not 1 or 2. not sure how to treat this data.")
}
# Round values to 1 decimal place
gen.cost.data[, c('Heat Rate', 'Load Point') := list(round(`Heat Rate`, 1), round(`Load Point`, 1))]
all.tabs <- c(all.tabs, "gen.cost.data")
#------------------------------------------------------------------------------|
# start costs ----
#------------------------------------------------------------------------------|
# requires that fuel.price and gen.fuel tables have been read in (see section
# "fuels and fuel price")
gen.startshut <- cbind(generator.data[,.(Generator)],
struct.list$gencost[,.(startup, shutdown)])
# start and shutdown costs are given in MMBtu. convert this to $ by
# adding gen fuel type and fuel prices, then multiplying by fuel price
gen.startshut <- merge(gen.startshut, gen.fuel, by = "Generator", all.x = TRUE)
gen.startshut <- merge(gen.startshut, fuel.price, by = "Fuel", all.x = TRUE)
gen.startshut[, Price := as.numeric(Price)]
# Use Oil/Steam price to calculate coal gen start and shutdown costs
gen.startshut[Fuel == "Coal/Steam", Price := fuel.price[Fuel == "Oil/Steam", Price]]
# calculate and add start and shutdown costs based on input heat and fuel price
gen.startshut[, `Start Cost` := Price * as.numeric(startup)]
gen.startshut[, `Shutdown Cost` := Price * as.numeric(shutdown)]
# save only plexos property columns
gen.startshut <- gen.startshut[,.(Generator, `Start Cost`, `Shutdown Cost`)]
# round values to integers
gen.startshut[, c('Start Cost', 'Shutdown Cost') := list(round(`Start Cost`), round(`Shutdown Cost`))]
all.tabs <- c(all.tabs, "gen.startshut")
#------------------------------------------------------------------------------|
# attach VG ----
#------------------------------------------------------------------------------|
# two things: 1. pass through filepointerts to VG rating files (these files
# are created manually based on site selection) 2. add a new generator for all
# the VG gens
# assumes generator.data has already been made
# assumes gen.fuel is already made
# read in profiles to read out again (inefficient but at least treated the
# same as all other property files...)
gen.da.vg <- fread("../../RTS_Data/vg_gens_DA.csv")
gen.rt.vg <- fread("../../RTS_Data/vg_gens_RT.csv")
gen.csp <- fread("../../RTS_Data/csp_gens.csv")
storage.csp <- fread("../../RTS_Data/storage.csp.csv")
storage.props <- fread("../../RTS_Data/storage.props.csv")
storage.props.rt <- fread("../../RTS_Data/storage.props.rt.csv")
# get vg max cap and add to total generator.table
vg.gens <- fread("../../RTS_Data/vg_gens_maxMW.csv", colClasses = "character")
# add node
vg.gens[,Node := tstrsplit(Generator, "_")[[1]]]
vg.gens[, `Min Stable Level` := "0"]
generator.data <- merge(generator.data,
vg.gens,
by = c("Generator", "Max Capacity", "Node"),
all = TRUE)
# add units since don't have this in mpc file
generator.data[, Units := "1"]
# get rid of some PV/Wind units
disappear.units <- c("101_pv","101_pv_2","101_pv_3","101_pv_4","102_pv","103_pv","104_pv",
"119_pv","310_pv","310_pv_2","312_pv","314_pv","314_pv_2","314_pv_3",
"314_pv_4","319_pv","324_pv","324_pv_2","324_pv_3","118_rtpv","118_rtpv_8",
"308_rtpv","313_rtpv_11","320_rtpv","320_rtpv_2","320_rtpv_3","320_rtpv_4",
"320_rtpv_5","320_rtpv_6","314_pv_5","303_wind","317_wind", "212_csp")
generator.data[Generator %in% disappear.units, Units:="0"]
# add fuel types to these gens
vg.gen.fuel <- vg.gens[,.(Generator)]
vg.gen.fuel[grepl("_pv", Generator), Fuel := "PV"]
vg.gen.fuel[grepl("_csp", Generator), Fuel := "CSP"]
vg.gen.fuel[grepl("_rtpv", Generator), Fuel := "RTPV"]
vg.gen.fuel[grepl("_wind", Generator), Fuel := "Wind"]
gen.fuel <- rbind(gen.fuel, vg.gen.fuel)
# add these to all.tabs to be written out at the end
all.tabs <- c(all.tabs, "gen.da.vg", "gen.rt.vg", "gen.csp", "storage.csp", "storage.props", "storage.props.rt")
#------------------------------------------------------------------------------|
# min gen ----
#------------------------------------------------------------------------------|
# have to match min gen to individual unit, because these are by size and fuel
gen.mingen <- merge(gen.id[, .(Generator, Unit, PG)],
gen.params[,.(Unit, MinGen)],
by = "Unit",
all.x = TRUE)
# keep only relevant columns
gen.mingen <- gen.mingen[,.(Generator, `Min Stable Level` = MinGen)]
gen.mingen.rtpv <- gen.fuel[Fuel=='RTPV']
gen.mingen.rtpv[, Fuel := NULL]
gen.mingen.rtpv0 <- gen.mingen.rtpv
gen.mingen.rtpv0[, `Min Stable Level` := 0]
gen.mingen.rtpv = merge(gen.mingen.rtpv, generator.data[,.(Generator, `Max Capacity`)], by='Generator')
gen.mingen.rtpv[, `Min Stable Level` := as.numeric(`Max Capacity`)*0.6 ]
gen.mingen.rtpv[, `Max Capacity` := NULL]
gen.mingen.rtpv[, `Min Stable Level` := round(`Min Stable Level`)]
gen.mingen = rbind(gen.mingen, gen.mingen.rtpv)
# add to all.tabs to be written out
all.tabs <- c(all.tabs, "gen.mingen", "gen.mingen.rtpv0")
#------------------------------------------------------------------------------|
# attach hydro ----
#------------------------------------------------------------------------------|
# just like vg profiles, just read in to write out (to keep in same format as
# everything else and also in case we need to do something with it eventually)
gen.hydro <- fread("../../RTS_Data/hydro_profiles.csv")
# add to all.tabs
all.tabs <- c(all.tabs, "gen.hydro")
#------------------------------------------------------------------------------|
eligible.gens <- c("Oil/Steam","Coal/Steam","Oil/CT","NG/CC","NG/CT","PV","Wind", "CSP")
# add reserve(s) which is x% of load in each region and what gens can provide it
l.reserve <- c("Spin Up")
l.is.enabled <- c(-1)
l.reserve.type <- c(1)
l.reserve.percent <- c(3.0)
l.scenario.name <- c("Add Spin Up")
l.reserve.violation <- c(4000.0)
l.reserve.timeframe.sec <- c(600.0)
l.mutually.exclusive <- c(1)
# add reserve(s) in which risk is defined with data file
d.reserve <- c("Flex Up","Flex Down","Reg Up","Reg Down")
d.is.enabled <- c(-1,-1,-1,-1)
d.reserve.type <- c(1,2,1,2)
d.scenario.name <- c("Add Flex Reserves","Add Flex Reserves","Add Regulation Reserves","Add Regulation Reserves")
d.reserve.violation <- c(4100,4100,3900,3900)
d.reserve.timeframe.sec <- c(1200.0,1200.0,300.0,300.0)
d.mutually.exclusive <- c(1,1,1,1)
reserve.data <- data.table('Reserve' = c(l.reserve,d.reserve),
'Is Enabled' = c(l.is.enabled,d.is.enabled),
'Type' = c(l.reserve.type,d.reserve.type),
'Scenario' = c(l.scenario.name,d.scenario.name),
'Timeframe' = c(l.reserve.timeframe.sec,d.reserve.timeframe.sec),
'VoRS' = c(l.reserve.violation,d.reserve.violation),
'Mutually Exclusive' = c(l.mutually.exclusive,d.mutually.exclusive))
View(reserve.data)
reserve.generators <- gen.fuel[Fuel %in% eligible.gens,]
View(reserve.generators)
reserve.generators <- reserve.generators[,.(Reserve = c(rep(l.reserve,length(Generator)*length(l.reserve)),rep(d.reserve,each = length(Generator))),
Generator = c(rep(Generator,times = length(l.reserve)+length(d.reserve))))]
View(reserve.generators)
reserve.regions <- region.refnode.data[]
View(reserve.regions)
reserve.regions <- reserve.regions[,.(Reserve = l.reserve,Region,`Load Risk` = l.reserve.percent)]
View(reserve.regions)
reserve.generators <- gen.fuel[Fuel %in% eligible.gens,]
reserve.generators <- reserve.generators[,.(Reserve = c(rep(l.reserve,length(Generator)*length(l.reserve)),rep(d.reserve,each = length(Generator))),
Generator = c(rep(Generator,times = length(l.reserve)+length(d.reserve))))]
reserve.generators <- gen.fuel[Fuel %in% eligible.gens,]
View(reserve.generators)
reserve.generators <- reserve.generators[,.(Reserve = c(rep(l.reserve,length(Generator)*length(l.reserve)),rep(d.reserve,each = length(Generator))),
Generator = c(rep(Generator,times = length(l.reserve)+length(d.reserve))))]
View(reserve.generators)
l.reserve
d.reserve
reserve.generators <- gen.fuel[Fuel %in% eligible.gens,]
View(reserve.generators)
reserve.generators.noCSP <- reserve.generators[!Fuel == 'CSP',]
reserve.generators <- reserve.generators[,.(Reserve = c(rep(l.reserve,length(Generator)*length(l.reserve)),rep(d.reserve,each = length(Generator))),
Generator = c(rep(Generator,times = length(l.reserve)+length(d.reserve))))]
reserve.generators.noCSP <- reserve.generators.noCSP[,.(Reserve = c(rep(l.reserve,length(Generator)*length(l.reserve)),rep(d.reserve,each = length(Generator))),
Generator = c(rep(Generator,times = length(l.reserve)+length(d.reserve))))]
View(reserve.generators)
View(reserve.generators.noCSP)
